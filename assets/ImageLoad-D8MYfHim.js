import{j as Ot,z as ie,a5 as ae,h as qt,I as ce,b as w,a2 as Dt,a6 as ue,f as Bt,a7 as le,a8 as fe}from"./index-Di-6ARBW.js";import{C as de}from"./Card-BFZDpZRY.js";const Ke=t=>{const{animation:e=!0,asElement:n="span",className:s,height:a,ref:r,style:i,variant:d="block",width:p}=t;return Ot.jsx(n,{ref:r,className:ie("skeleton",d==="circle"&&"skeleton-circle",d==="block"&&"skeleton-block",e&&"animate-pulse",s),style:{width:p,height:a,...i}})},Ye=t=>{const{adaptiveCardActive:e}=ae(),{className:n,bodyClass:s,...a}=t;return Ot.jsx(de,{className:qt(n,e&&"border-none dark:bg-transparent"),bodyClass:qt(s,e&&"p-0"),...a})};var ut={exports:{}},lt={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Mt;function Ee(){if(Mt)return lt;Mt=1;var t=ce();function e(c,l){return c===l&&(c!==0||1/c===1/l)||c!==c&&l!==l}var n=typeof Object.is=="function"?Object.is:e,s=t.useState,a=t.useEffect,r=t.useLayoutEffect,i=t.useDebugValue;function d(c,l){var f=l(),D=s({inst:{value:f,getSnapshot:l}}),E=D[0].inst,q=D[1];return r(function(){E.value=f,E.getSnapshot=l,p(E)&&q({inst:E})},[c,f,l]),a(function(){return p(E)&&q({inst:E}),c(function(){p(E)&&q({inst:E})})},[c]),i(f),f}function p(c){var l=c.getSnapshot;c=c.value;try{var f=l();return!n(c,f)}catch{return!0}}function y(c,l){return l()}var g=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?y:d;return lt.useSyncExternalStore=t.useSyncExternalStore!==void 0?t.useSyncExternalStore:g,lt}var kt;function pe(){return kt||(kt=1,ut.exports=Ee()),ut.exports}var me=pe(),$t=Object.prototype.hasOwnProperty;function Rt(t,e){var n,s;if(t===e)return!0;if(t&&e&&(n=t.constructor)===e.constructor){if(n===Date)return t.getTime()===e.getTime();if(n===RegExp)return t.toString()===e.toString();if(n===Array){if((s=t.length)===e.length)for(;s--&&Rt(t[s],e[s]););return s===-1}if(!n||typeof t=="object"){s=0;for(n in t)if($t.call(t,n)&&++s&&!$t.call(e,n)||!(n in e)||!Rt(t[n],e[n]))return!1;return Object.keys(e).length===s}}return t!==t&&e!==e}const F=new WeakMap,U=()=>{},O=U(),St=Object,u=t=>t===O,N=t=>typeof t=="function",W=(t,e)=>({...t,...e}),Jt=t=>N(t.then),ft={},rt={},yt="undefined",it=typeof window!=yt,gt=typeof document!=yt,he=()=>it&&typeof window.requestAnimationFrame!=yt,Kt=(t,e)=>{const n=F.get(t);return[()=>!u(e)&&t.get(e)||ft,s=>{if(!u(e)){const a=t.get(e);e in rt||(rt[e]=a),n[5](e,W(a,s),a||ft)}},n[6],()=>!u(e)&&e in rt?rt[e]:!u(e)&&t.get(e)||ft]};let vt=!0;const Re=()=>vt,[Tt,_t]=it&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[U,U],Se=()=>{const t=gt&&document.visibilityState;return u(t)||t!=="hidden"},ge=t=>(gt&&document.addEventListener("visibilitychange",t),Tt("focus",t),()=>{gt&&document.removeEventListener("visibilitychange",t),_t("focus",t)}),ve=t=>{const e=()=>{vt=!0,t()},n=()=>{vt=!1};return Tt("online",e),Tt("offline",n),()=>{_t("online",e),_t("offline",n)}},Te={isOnline:Re,isVisible:Se},_e={initFocus:ge,initReconnect:ve},Ht=!Dt.useId,Z=!it||"Deno"in globalThis,we=t=>he()?window.requestAnimationFrame(t):setTimeout(t,1),dt=Z?w.useEffect:w.useLayoutEffect,Et=typeof navigator<"u"&&navigator.connection,Gt=!Z&&Et&&(["slow-2g","2g"].includes(Et.effectiveType)||Et.saveData),ot=new WeakMap,pt=(t,e)=>St.prototype.toString.call(t)===`[object ${e}]`;let Ce=0;const wt=t=>{const e=typeof t,n=pt(t,"Date"),s=pt(t,"RegExp"),a=pt(t,"Object");let r,i;if(St(t)===t&&!n&&!s){if(r=ot.get(t),r)return r;if(r=++Ce+"~",ot.set(t,r),Array.isArray(t)){for(r="@",i=0;i<t.length;i++)r+=wt(t[i])+",";ot.set(t,r)}if(a){r="#";const d=St.keys(t).sort();for(;!u(i=d.pop());)u(t[i])||(r+=i+":"+wt(t[i])+",");ot.set(t,r)}}else r=n?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return r},At=t=>{if(N(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?wt(t):"",[t,e]};let Oe=0;const Ct=()=>++Oe,Yt=0,Xt=1,Qt=2,De=3;var Q={__proto__:null,ERROR_REVALIDATE_EVENT:De,FOCUS_EVENT:Yt,MUTATE_EVENT:Qt,RECONNECT_EVENT:Xt};async function Zt(...t){const[e,n,s,a]=t,r=W({populateCache:!0,throwOnError:!0},typeof a=="boolean"?{revalidate:a}:a||{});let i=r.populateCache;const d=r.rollbackOnError;let p=r.optimisticData;const y=l=>typeof d=="function"?d(l):d!==!1,g=r.throwOnError;if(N(n)){const l=n,f=[],D=e.keys();for(const E of D)!/^\$(inf|sub)\$/.test(E)&&l(e.get(E)._k)&&f.push(E);return Promise.all(f.map(c))}return c(n);async function c(l){const[f]=At(l);if(!f)return;const[D,E]=Kt(e,f),[q,o,tt,Y]=F.get(e),j=()=>{const b=q[f];return(N(r.revalidate)?r.revalidate(D().data,l):r.revalidate!==!1)&&(delete tt[f],delete Y[f],b&&b[0])?b[0](Qt).then(()=>D().data):D().data};if(t.length<3)return j();let T=s,A;const k=Ct();o[f]=[k,0];const S=!u(p),$=D(),V=$.data,H=$._c,M=u(H)?V:H;if(S&&(p=N(p)?p(M,V):p,E({data:p,_c:M})),N(T))try{T=T(M)}catch(b){A=b}if(T&&Jt(T))if(T=await T.catch(b=>{A=b}),k!==o[f][0]){if(A)throw A;return T}else A&&S&&y(A)&&(i=!0,E({data:M,_c:O}));if(i&&!A)if(N(i)){const b=i(T,M);E({data:b,error:O,_c:O})}else E({data:T,error:O,_c:O});if(o[f][1]=Ct(),Promise.resolve(j()).then(()=>{E({_c:O})}),A){if(g)throw A;return}return T}}const zt=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},ye=(t,e)=>{if(!F.has(t)){const n=W(_e,e),s={},a=Zt.bind(O,t);let r=U;const i={},d=(g,c)=>{const l=i[g]||[];return i[g]=l,l.push(c),()=>l.splice(l.indexOf(c),1)},p=(g,c,l)=>{t.set(g,c);const f=i[g];if(f)for(const D of f)D(c,l)},y=()=>{if(!F.has(t)&&(F.set(t,[s,{},{},{},a,p,d]),!Z)){const g=n.initFocus(setTimeout.bind(O,zt.bind(O,s,Yt))),c=n.initReconnect(setTimeout.bind(O,zt.bind(O,s,Xt)));r=()=>{g&&g(),c&&c(),F.delete(t)}}};return y(),[t,a,y,r]}return[t,F.get(t)[4]]},Ae=(t,e,n,s,a)=>{const r=n.errorRetryCount,i=a.retryCount,d=~~((Math.random()+.5)*(1<<(i<8?i:8)))*n.errorRetryInterval;!u(r)&&i>r||setTimeout(s,d,a)},Ie=Rt,[te,be]=ye(new Map),Ve=W({onLoadingSlow:U,onSuccess:U,onError:U,onErrorRetry:Ae,onDiscarded:U,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:Gt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:Gt?5e3:3e3,compare:Ie,isPaused:()=>!1,cache:te,mutate:be,fallback:{}},Te),Le=(t,e)=>{const n=W(t,e);if(e){const{use:s,fallback:a}=t,{use:r,fallback:i}=e;s&&r&&(n.use=s.concat(r)),a&&i&&(n.fallback=W(a,i))}return n},Ne=w.createContext({}),xe="$inf$",ee=it&&window.__SWR_DEVTOOLS_USE__,Pe=ee?window.__SWR_DEVTOOLS_USE__:[],Fe=()=>{ee&&(window.__SWR_DEVTOOLS_REACT__=Dt)},je=t=>N(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],Ue=()=>W(Ve,w.useContext(Ne)),We=t=>(e,n,s)=>t(e,n&&((...r)=>{const[i]=At(e),[,,,d]=F.get(te);if(i.startsWith(xe))return n(...r);const p=d[i];return u(p)?n(...r):(delete d[i],p)}),s),qe=Pe.concat(We),Me=t=>function(...n){const s=Ue(),[a,r,i]=je(n),d=Le(s,i);let p=t;const{use:y}=d,g=(y||[]).concat(qe);for(let c=g.length;c--;)p=g[c](p);return p(a,r||d.fetcher||null,d)},ke=(t,e,n)=>{const s=e[t]||(e[t]=[]);return s.push(n),()=>{const a=s.indexOf(n);a>=0&&(s[a]=s[s.length-1],s.pop())}};Fe();const mt=Dt.use||(t=>{switch(t.status){case"pending":throw t;case"fulfilled":return t.value;case"rejected":throw t.reason;default:throw t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t}}),ht={dedupe:!0},$e=(t,e,n)=>{const{cache:s,compare:a,suspense:r,fallbackData:i,revalidateOnMount:d,revalidateIfStale:p,refreshInterval:y,refreshWhenHidden:g,refreshWhenOffline:c,keepPreviousData:l}=n,[f,D,E,q]=F.get(s),[o,tt]=At(t),Y=w.useRef(!1),j=w.useRef(!1),T=w.useRef(o),A=w.useRef(e),k=w.useRef(n),S=()=>k.current,$=()=>S().isVisible()&&S().isOnline(),[V,H,M,b]=Kt(s,o),G=w.useRef({}).current,et=u(i)?u(n.fallback)?O:n.fallback[o]:i,bt=(m,h)=>{for(const _ in G){const R=_;if(R==="data"){if(!a(m[R],h[R])&&(!u(m[R])||!a(st,h[R])))return!1}else if(h[R]!==m[R])return!1}return!0},Vt=w.useMemo(()=>{const m=!o||!e?!1:u(d)?S().isPaused()||r?!1:p!==!1:d,h=C=>{const x=W(C);return delete x._k,m?{isValidating:!0,isLoading:!0,...x}:x},_=V(),R=b(),L=h(_),K=_===R?L:h(R);let v=L;return[()=>{const C=h(V());return bt(C,v)?(v.data=C.data,v.isLoading=C.isLoading,v.isValidating=C.isValidating,v.error=C.error,v):(v=C,C)},()=>K]},[s,o]),z=me.useSyncExternalStore(w.useCallback(m=>M(o,(h,_)=>{bt(_,h)||m()}),[s,o]),Vt[0],Vt[1]),Lt=!Y.current,ne=f[o]&&f[o].length>0,B=z.data,J=u(B)?et&&Jt(et)?mt(et):et:B,nt=z.error,Nt=w.useRef(J),st=l?u(B)?Nt.current:B:J,xt=ne&&!u(nt)?!1:Lt&&!u(d)?d:S().isPaused()?!1:r?u(J)?!1:p:u(J)||p,Pt=!!(o&&e&&Lt&&xt),se=u(z.isValidating)?Pt:z.isValidating,re=u(z.isLoading)?Pt:z.isLoading,X=w.useCallback(async m=>{const h=A.current;if(!o||!h||j.current||S().isPaused())return!1;let _,R,L=!0;const K=m||{},v=!E[o]||!K.dedupe,C=()=>Ht?!j.current&&o===T.current&&Y.current:o===T.current,x={isValidating:!1,isLoading:!1},jt=()=>{H(x)},Ut=()=>{const I=E[o];I&&I[1]===R&&delete E[o]},Wt={isValidating:!0};u(V().data)&&(Wt.isLoading=!0);try{if(v&&(H(Wt),n.loadingTimeout&&u(V().data)&&setTimeout(()=>{L&&C()&&S().onLoadingSlow(o,n)},n.loadingTimeout),E[o]=[h(tt),Ct()]),[_,R]=E[o],_=await _,v&&setTimeout(Ut,n.dedupingInterval),!E[o]||E[o][1]!==R)return v&&C()&&S().onDiscarded(o),!1;x.error=O;const I=D[o];if(!u(I)&&(R<=I[0]||R<=I[1]||I[1]===0))return jt(),v&&C()&&S().onDiscarded(o),!1;const P=V().data;x.data=a(P,_)?P:_,v&&C()&&S().onSuccess(_,o,n)}catch(I){Ut();const P=S(),{shouldRetryOnError:at}=P;P.isPaused()||(x.error=I,v&&C()&&(P.onError(I,o,P),(at===!0||N(at)&&at(I))&&(!S().revalidateOnFocus||!S().revalidateOnReconnect||$())&&P.onErrorRetry(I,o,P,oe=>{const ct=f[o];ct&&ct[0]&&ct[0](Q.ERROR_REVALIDATE_EVENT,oe)},{retryCount:(K.retryCount||0)+1,dedupe:!0})))}return L=!1,jt(),!0},[o,s]),Ft=w.useCallback((...m)=>Zt(s,T.current,...m),[]);if(dt(()=>{A.current=e,k.current=n,u(B)||(Nt.current=B)}),dt(()=>{if(!o)return;const m=X.bind(O,ht);let h=0;const R=ke(o,f,(L,K={})=>{if(L==Q.FOCUS_EVENT){const v=Date.now();S().revalidateOnFocus&&v>h&&$()&&(h=v+S().focusThrottleInterval,m())}else if(L==Q.RECONNECT_EVENT)S().revalidateOnReconnect&&$()&&m();else{if(L==Q.MUTATE_EVENT)return X();if(L==Q.ERROR_REVALIDATE_EVENT)return X(K)}});return j.current=!1,T.current=o,Y.current=!0,H({_k:tt}),xt&&(u(J)||Z?m():we(m)),()=>{j.current=!0,R()}},[o]),dt(()=>{let m;function h(){const R=N(y)?y(V().data):y;R&&m!==-1&&(m=setTimeout(_,R))}function _(){!V().error&&(g||S().isVisible())&&(c||S().isOnline())?X(ht).then(h):h()}return h(),()=>{m&&(clearTimeout(m),m=-1)}},[y,g,c,o]),w.useDebugValue(st),r&&u(J)&&o){if(!Ht&&Z)throw new Error("Fallback data is required when using Suspense in SSR.");A.current=e,k.current=n,j.current=!1;const m=q[o];if(!u(m)){const h=Ft(m);mt(h)}if(u(nt)){const h=X(ht);u(st)||(h.status="fulfilled",h.value=!0),mt(h)}else throw nt}return{mutate:Ft,get data(){return G.data=!0,st},get error(){return G.error=!0,nt},get isValidating(){return G.isValidating=!0,se},get isLoading(){return G.isLoading=!0,re}}},He=Me($e),It=ue.create({timeout:6e4,baseURL:Bt.apiPrefixDGP});It.interceptors.request.use(t=>le(t),t=>Promise.reject(t));It.interceptors.response.use(t=>t,t=>(fe(t),Promise.reject(t)));const Ge={fetchDataWithAxios(t){return new Promise((e,n)=>{It(t).then(s=>{e(s.data)}).catch(s=>{n(s)})})}};async function ze(t){return Ge.fetchDataWithAxios({url:t,method:"get"})}function Xe(t){const{data:e,error:n,isLoading:s,mutate:a}=He(t?[`/escenarios/show/${t}/pi`]:null,([r])=>ze(r),{revalidateOnFocus:!1});return{escenario:e?.escenario||{},data:e?.plantillas||{},error:n,isLoading:s,mutate:a}}const Qe=({path:t})=>{const e=`${Bt.urlImagePrefixDGP}/${t}`;return Ot.jsx("img",{src:e,alt:"Mapa iamge"})};export{Ye as A,Qe as I,Ke as S,Xe as u};
